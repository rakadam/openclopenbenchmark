
//OpenCL
//MAX_GLOBAL_SIZE(0):4096
//MAX_GLOBAL_SIZE(1):1
//MAX_GLOBAL_SIZE(2):1
//MAX_LOCAL_SIZE(0):0
//MAX_LOCAL_SIZE(1):1
//MAX_LOCAL_SIZE(2):1
//MIN_LOCAL_SIZE(0):4
//MIN_LOCAL_SIZE(1):1
//MIN_LOCAL_SIZE(2):1

kernel void parallel_projection_y_2d(read_only image2d_t image1_2d)
{
  const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;
  
  int y = get_global_id(0);
  
  int2 dim = get_image_dim(image1_2d);
  
  float sum = 0;
  
  for(int x = 0; x < dim.x; x++)
  {
    float2 pos = {x+0.5f, y+0.5f};
    sum += read_imagef(image1_2d, sampler, pos).x;
  }
  //kiirás a memóriába: mibe?
}


//Gold
#ifndef __OPENCL_VERSION__

void host_init_parallel_projection_y_2d(ocl_test& test)
{
  cl_image_format myformat;
  
  myformat.image_channel_order = CL_INTENSITY;
  myformat.image_channel_data_type = CL_FLOAT;
  
  int mx = 4096;
  int my = 4096;
  
  cl_int err;
  test.dev_image1_2d = clCreateImage2D(test.context, CL_MEM_READ_ONLY, &myformat, mx, my, 0, NULL, &err);
  test.geterr(err, __LINE__, __FILE__);
  
  std::vector<float> data(mx*my);
  
  for (int i = 0; i < int(data.size()); i++)
  {
    data[i] = i%255;
  }
  
  const size_t origin[3] = {0, 0, 0};
  const size_t region[3] = {mx, my, 1};
  
  clEnqueueWriteImage(test.command_queue, test.dev_image1_2d, true, origin, region, 0, 0, &data[0], 0, NULL, NULL);
  
  test.host_image1_2d = malloc(sizeof(data[0])*data.size());
  
  memcpy(test.host_image1_2d, &data[0], sizeof(data[0])*data.size());
}

void parallel_projection_y_2d(void* image1_2d)
{
}
